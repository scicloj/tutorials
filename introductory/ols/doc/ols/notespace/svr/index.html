<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://stackpath.bootstrapcdn.com/bootswatch/4.5.0/sandstone/bootstrap.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/solarized-light.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-grid.min.css" rel="stylesheet" type="text/css">
        <link href="https://cdnjs.cloudflare.com/ajax/libs/ag-grid/24.0.0/styles/ag-theme-balham.min.css" rel="stylesheet" type="text/css">
        <link href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css" rel="stylesheet" type="text/css">
    </head>
    <body>
        <p id="loading">Loading ...</p>
        <div id="app"></div>
    </body>
    <script src="https://cdn.jsdelivr.net/gh/scicloj/gorilla-notes@master/dist/0.5.0-SNAPSHOT-5/main.js"></script>
    <script>
     shadow.loader.load("main");
     gorilla_notes.main.main_BANG_(false, "{:options {:reverse-notes? false, :header? false, :notes-in-cards? false, :custom-header [:div {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} \"(notespace)\" [:p \"Sat Dec 12 22:47:23 IST 2020\"] nil nil [:hr]], :custom-footer [:div [:hr]]}, :ids [\"975\" \"976\" \"977\" \"978\" \"979\" \"980\" \"981\" \"982\" \"983\" \"984\" \"985\" \"986\" \"987\" \"988\" \"989\" \"990\" \"991\" \"992\" \"993\" \"994\" \"995\" \"996\" \"997\" \"998\" \"999\" \"1000\" \"1001\" \"1002\" \"1003\" \"1004\" \"1005\" \"1006\" \"1007\" \"1008\"], :id->content {\"984\" [:div [:p/code {:code \"(defn build-column\\n  \\\"We can either assoc a new column or build from existing columns\\\"\\n  [dataset line]\\n  (if (contains? line :assoc-fn)\\n    (assoc dataset (:column line) ((:assoc-fn line) dataset))\\n    (ds/column-map dataset (:column line) (:map-fn line) nil (:arg-cols line))))\", :bg-class \"bg-light\"}] [:div nil]], \"977\" [:div [:p/code {:code \"(comment\\n  ;; we'll be calling some Java methods\\n  ;; commenting this out, since it fails as a notespace note\\n  ;; (Can't set!: *warn-on-reflection* from non-binding thread)\\n  (set! *warn-on-reflection* true))\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"nil\\n\"}]]], \"965\" [:div [:p/code {:code \"(def qm (ds/->dataset \\\"resources/bonds.csv\\\" {:key-fn keyword}) )\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"945\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"955\" [:div [:p/code {:code \"(defn ols-full-training\\n  \\\"Putting it all together, the model / the predictions and the R2\\\"\\n  [data]\\n  (let [ols (OLS/fit (:ols-formula data) (:dataframe data))]\\n    (merge data {:ols ols :predictions ((get-in data [:y :predict-fn]) (vec (.predict ^LinearModel ols ^DataFrame (:dataframe data)))) :rsq (.RSquared ^LinearModel ols)})))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"978\" [:div nil [:div [:p/markdown \"## MODEL DEFINITIONS\"]]], \"941\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"1005\" [:div [:p/code {:code \"(ds/filter-column res :Bond \\\"Bond-42\\\")\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"resources/bonds.csv [1 9]:\\n\\n|   :Bond |     :Sector | :Country | :Used_Duration | :Used_Rating_Score | :Used_ZTW | :legacy |  :new |  :svr |\\n|---------|-------------|----------|----------------|--------------------|-----------|---------|-------|-------|\\n| Bond-42 | Ovy_naq_Gnf |       BH |           1.16 |                6.0 |      75.2 |   118.0 | 103.1 | 75.15 |\\n\\n\"}]]], \"1008\" [:div [:p/code {:code \"(svr-predict-scalar svrmodel {:Used_Duration 1.16 :Used_Rating_Score 6.0 :Country \\\"BH\\\" :Sector \\\"Ovy_naq_Gnf\\\"})\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"75.14854935593735\\n\"}]]], \"972\" [:div [:p/code {:code \"(ols-predict-scalar legacymodel {:Used_Duration 1.16 :Used_Rating_Score 6.0 :Country \\\"BH\\\" :Sector \\\"Ovy_naq_Gnf\\\"})\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"975\" [:div nil [:div nil]], \"995\" [:div nil [:div [:p/markdown \"## ACTUALLY DO IT\"]]], \"979\" [:div nil [:div [:p/markdown \"The source data columns are `[:Bond :Used_Duration :Used_Rating_Score :Country :Sector]`\"]]], \"993\" [:div [:p/code {:code \"(defn ols-predict-scalar [data xmap]\\n  \\\"The order of the data needs to match the order of the training data AND we need the intercept first, set at 1.0\\n  Ugly hack here - normalizer is set to use log for new model\\n  \\\"\\n  (letfn [(normalizer [id log?] (let [{m :mean s :standard-deviation} (get-in data [:std-scale :scaler id])] (/ (- (if log? (Math/log (xmap id)) (xmap id)) m) s)))]\\n    ((get-in data [:y :predict-fn])\\n     (.predict\\n       ^LinearModel (:ols data)\\n       (double-array\\n         (into [1.0] (for [c (:features-cols data)]          ;into [1.0] is the intercept. It's not obvious!!!\\n                       (condp = c\\n                         :Used_Duration (normalizer :Used_Duration (some #{:Used_Duration} (map :column (:transformations data))))\\n                         :Used_Rating_Score (normalizer :Used_Rating_Score false)\\n                         (keyword (str \\\"Country-\\\" (xmap :Country))) 1.0\\n                         (keyword (str \\\"Sector-\\\" (xmap :Sector))) 1.0\\n                         0.0))))))))\", :bg-class \"bg-light\"}] [:div nil]], \"958\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"996\" [:div [:p/code {:code \"(defn get-svr-model-output [dataset]\\n  (-> dataset\\n      (svr-model-definition)\\n      (prepare-data :svr)\\n      (svr-full-training 0.05 1000)))\", :bg-class \"bg-light\"}] [:div nil]], \"943\" [:div [:p/code {:code \"(comment\\n  ;; we'll be calling some Java methods\\n  ;; commenting this out, since it fails as a notespace note\\n  ;; (Can't set!: *warn-on-reflection* from non-binding thread)\\n  (set! *warn-on-reflection* true))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"957\" [:div [:p/code {:code \"(defn svr-full-training [data eps C]\\n  \\\"Putting it all together, the model / the predictions and the R2\\\"\\n  ;todo find out why I'm still getting a Reflection warning: call to method predict on smile.base.svm.KernelMachine can't be resolved (no such method)\\n  (let [kernel-machine (fit-RBF-SVR (:features-array data) (:y-array data) (:sigma data) eps C)\\n        raw-predictions (.predict ^KernelMachine kernel-machine (:features-array data))\\n        rss (RSS/of (:y-array data) raw-predictions)]\\n    (merge data {:kernel-machine kernel-machine :predictions ((get-in data [:y :predict-fn]) (vec raw-predictions)) :rsq (- 1 (/ rss (dfn/distance-squared (:y-array data) (repeat 0.))))})))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"949\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"985\" [:div [:p/code {:code \"(defn build-many-columns [dataset features]\\n  (reduce build-column dataset features))\", :bg-class \"bg-light\"}] [:div nil]], \"953\" [:div [:p/code {:code \"(defn prepare-data\\n  \\\"The scaling parameters are added here for features that had been transformed. model-type is :ols or :svr\\\"\\n  [model-definition model-type]\\n  (let [transformed (build-many-columns (:dataset model-definition) (:transformations model-definition))\\n        scaler (dsm/fit-std-scale (ds/select-columns transformed (get-in model-definition [:std-scale :columns])))\\n        clean-data (-> transformed\\n                       (one-hot-reducer (get-in model-definition [:one-hot :columns]) (get-in model-definition [:one-hot :removals]))\\n                       (dsm/transform-std-scale scaler))\\n        features-ds (ds/remove-columns clean-data [(:id-name model-definition) (get-in model-definition [:y :column])])]\\n    (assoc model-definition\\n      :std-scale      (assoc (:std-scale model-definition) :scaler scaler)\\n      :features-cols  (ds/column-names features-ds) ;we need to know the order to predict later\\n      :ols-formula    (if (= :ols model-type) (Formula/lhs (name (get-in model-definition [:y :column])))) ; warning - you need a name here, keyword will fail\\n      :dataframe      (if (= :ols model-type) (ds-smile/dataset->dataframe (ds/remove-column clean-data (:id-name model-definition))))\\n      :sigma          (if (= :svr model-type) (Math/sqrt (* 0.5 (ds/column-count features-ds) (dfn/variance (vec (flatten (ds/value-reader features-ds)))))))\\n      :features-array (if (= :svr model-type) (.toArray (ds-smile/dataset->dataframe features-ds)))\\n      :y-array        (if (= :svr model-type) (.array (ds-smile/column->smile-column (clean-data (get-in model-definition [:y :column]))))))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"942\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"1002\" [:div [:p/code {:code \"(def newmodel (get-new-model-output qm))\", :bg-class \"bg-light\"}] [:div nil]], \"987\" [:div [:p/code {:code \"(defn prepare-data\\n  \\\"The scaling parameters are added here for features that had been transformed. model-type is :ols or :svr\\\"\\n  [model-definition model-type]\\n  (let [transformed (build-many-columns (:dataset model-definition) (:transformations model-definition))\\n        scaler (dsm/fit-std-scale (ds/select-columns transformed (get-in model-definition [:std-scale :columns])))\\n        clean-data (-> transformed\\n                       (one-hot-reducer (get-in model-definition [:one-hot :columns]) (get-in model-definition [:one-hot :removals]))\\n                       (dsm/transform-std-scale scaler))\\n        features-ds (ds/remove-columns clean-data [(:id-name model-definition) (get-in model-definition [:y :column])])]\\n    (assoc model-definition\\n      :std-scale      (assoc (:std-scale model-definition) :scaler scaler)\\n      :features-cols  (ds/column-names features-ds) ;we need to know the order to predict later\\n      :ols-formula    (if (= :ols model-type) (Formula/lhs (name (get-in model-definition [:y :column])))) ; warning - you need a name here, keyword will fail\\n      :dataframe      (if (= :ols model-type) (ds-smile/dataset->dataframe (ds/remove-column clean-data (:id-name model-definition))))\\n      :sigma          (if (= :svr model-type) (Math/sqrt (* 0.5 (ds/column-count features-ds) (dfn/variance (vec (flatten (ds/value-reader features-ds)))))))\\n      :features-array (if (= :svr model-type) (.toArray (ds-smile/dataset->dataframe features-ds)))\\n      :y-array        (if (= :svr model-type) (.array (ds-smile/column->smile-column (clean-data (get-in model-definition [:y :column]))))))))\", :bg-class \"bg-light\"}] [:div nil]], \"1001\" [:div [:p/code {:code \"(def svrmodel (get-svr-model-output qm))\", :bg-class \"bg-light\"}] [:div nil]], \"998\" [:div [:p/code {:code \"(defn get-new-model-output [dataset]\\n  (-> dataset\\n      (new-model-definition)\\n      (prepare-data :ols)\\n      (ols-full-training)))\", :bg-class \"bg-light\"}] [:div nil]], \"954\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"988\" [:div nil [:div [:p/markdown \"## smile TRAINING\"]]], \"983\" [:div nil [:div [:p/markdown \"## PREPARING THE DATA FOR smile PROCESSING\"]]], \"973\" [:div [:p/code {:code \"(ols-predict-scalar newmodel {:Used_Duration 1.16 :Used_Rating_Score 6.0 :Country \\\"BH\\\" :Sector \\\"Ovy_naq_Gnf\\\"})\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"969\" [:div [:p/code {:code \"(def legacymodel (get-legacy-model-output qm))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"999\" [:div [:p/code {:code \"(def qm (ds/->dataset \\\"resources/bonds.csv\\\" {:key-fn keyword}) )\", :bg-class \"bg-light\"}] [:div nil]], \"960\" [:div [:p/code {:code \"(defn svr-predict-scalar [data xmap]\\n  \\\"The order of the data needs to match the order of the training data.\\\"\\n  ;todo find out why I'm still getting a Reflection warning: call to method predict on smile.base.svm.KernelMachine can't be resolved (no such method)\\n  (letfn [(normalizer [id] (let [{m :mean s :standard-deviation} (get-in data [:std-scale :scaler id])] (/ (- (xmap id) m) s)))]\\n    ((get-in data [:y :predict-fn])\\n     (.predict\\n       ^KernelMachine (:kernel-machine data)\\n       (double-array\\n         (into [] (for [c (:features-cols data)]\\n                    (condp = c\\n                      :Used_Duration (normalizer :Used_Duration)\\n                      :Used_Rating_Score (normalizer :Used_Rating_Score)\\n                      (keyword (str \\\"Country-\\\" (xmap :Country))) 1.0\\n                      (keyword (str \\\"Sector-\\\" (xmap :Sector))) 1.0\\n                      0.0))))))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"948\" [:div [:p/code {:code \"(defn svr-model-definition\\n  \\\"Used_ZTW = SVR(Used_Duration, Used_Rating_Score, Country, Sector)\\\"\\n  [dataset]\\n  {:dataset         dataset\\n   :id-name         :Bond\\n   :y               {:column :Used_ZTW :predict-fn identity}\\n   :one-hot         {:columns [:Country :Sector] :removals [:Country-BH :Sector-Fvanapvny]}\\n   :std-scale       {:columns [:Used_Duration :Used_Rating_Score] :scaler nil}})\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"968\" [:div [:p/code {:code \"(def newmodel (get-new-model-output qm))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"989\" [:div [:p/code {:code \"(defn ols-full-training\\n  \\\"Putting it all together, the model / the predictions and the R2\\\"\\n  [data]\\n  (let [ols (OLS/fit (:ols-formula data) (:dataframe data))]\\n    (merge data {:ols ols :predictions ((get-in data [:y :predict-fn]) (vec (.predict ^LinearModel ols ^DataFrame (:dataframe data)))) :rsq (.RSquared ^LinearModel ols)})))\", :bg-class \"bg-light\"}] [:div nil]], \"1000\" [:div nil [:div [:p/markdown \"This is an anonymized dataset of bonds across countries and sectors, with their durations, rating and spread.\\nWe are trying to infer the spread (Used_ZTW = z-spread to worst)\"]]], \"992\" [:div nil [:div [:p/markdown \"## SCALAR PREDICTOR FUNCTIONS\"]]], \"970\" [:div [:p/code {:code \"(def res (assoc qm :legacy (:predictions legacymodel) :new (:predictions newmodel) :svr (:predictions svrmodel)))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"976\" [:div nil [:div [:p/markdown \"Note we are using smile Java interop.\\nThere's a \\\"native\\\" Clojure implementation but more doc for the Java version, hence using that one.\\nWe'll be spending as much time as possible within Clojure / tech.ml, and calling smile only for the actual regression.\"]]], \"982\" [:div [:p/code {:code \"(defn svr-model-definition\\n  \\\"Used_ZTW = SVR(Used_Duration, Used_Rating_Score, Country, Sector)\\\"\\n  [dataset]\\n  {:dataset         dataset\\n   :id-name         :Bond\\n   :y               {:column :Used_ZTW :predict-fn identity}\\n   :one-hot         {:columns [:Country :Sector] :removals [:Country-BH :Sector-Fvanapvny]}\\n   :std-scale       {:columns [:Used_Duration :Used_Rating_Score] :scaler nil}})\", :bg-class \"bg-light\"}] [:div nil]], \"966\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"990\" [:div [:p/code {:code \"(defn fit-RBF-SVR [x y sigma eps C]\\n  \\\"This is the SVR fit function, returning a smile.base.svm.KernelMachine which we can use to predict.\\n  x id a double double array, y is a double array, the rest are scalars.\\n  tol = 0.01 is irrelevant for the RBF (= Gaussian) kernel.\\n  sigma tunes the Kernel. The Python sklearn default is gamma = 'scale' where gamma = 1 / (2 * sigma^2)\\n  'scale' means gamma = 1 / (n_features * x.var()) hence sigma = sqrt(0.5 * n_features * x.var()) where x is flattened\\\"\\n  (.fit (SVR. (GaussianKernel. sigma) eps C 0.01) x y))\", :bg-class \"bg-light\"}] [:div nil]], \"1003\" [:div [:p/code {:code \"(def legacymodel (get-legacy-model-output qm))\", :bg-class \"bg-light\"}] [:div nil]], \"986\" [:div [:p/code {:code \"(defn one-hot-reducer\\n  \\\"Removals only important for OLS models with small amount of features to avoid colinearity\\\"\\n  [source-dataset cols removals]\\n  (ds/remove-columns\\n    (reduce (fn [dataset col] (categorical/transform-one-hot dataset (categorical/fit-one-hot dataset col))) source-dataset cols)\\n    removals))\", :bg-class \"bg-light\"}] [:div nil]], \"967\" [:div [:p/code {:code \"(def svrmodel (get-svr-model-output qm))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"947\" [:div [:p/code {:code \"(defn new-model-definition\\n  \\\"log(Used_ZTW) = a.log(Used_Duration) + b.Used_Rating_Score + categorical variables\\\"\\n  [dataset]\\n  {:dataset         dataset\\n   :id-name         :Bond\\n   :y               {:column :Used_ZTW :predict-fn dfn/exp}\\n   :transformations [{:column :Used_ZTW          :assoc-fn #(dfn/log (% :Used_ZTW))}\\n                     {:column :Used_Duration     :assoc-fn #(dfn/log (% :Used_Duration))}]\\n   :one-hot         {:columns [:Country :Sector] :removals [:Country-BH :Sector-Fvanapvny]}\\n   :std-scale       {:columns [:Used_Duration :Used_Rating_Score] :scaler nil}})\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"971\" [:div [:p/code {:code \"(ds/filter-column res :Bond \\\"Bond-42\\\")\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"994\" [:div [:p/code {:code \"(defn svr-predict-scalar [data xmap]\\n  \\\"The order of the data needs to match the order of the training data.\\\"\\n  ;todo find out why I'm still getting a Reflection warning: call to method predict on smile.base.svm.KernelMachine can't be resolved (no such method)\\n  (letfn [(normalizer [id] (let [{m :mean s :standard-deviation} (get-in data [:std-scale :scaler id])] (/ (- (xmap id) m) s)))]\\n    ((get-in data [:y :predict-fn])\\n     (.predict\\n       ^KernelMachine (:kernel-machine data)\\n       (double-array\\n         (into [] (for [c (:features-cols data)]\\n                    (condp = c\\n                      :Used_Duration (normalizer :Used_Duration)\\n                      :Used_Rating_Score (normalizer :Used_Rating_Score)\\n                      (keyword (str \\\"Country-\\\" (xmap :Country))) 1.0\\n                      (keyword (str \\\"Sector-\\\" (xmap :Sector))) 1.0\\n                      0.0))))))))\", :bg-class \"bg-light\"}] [:div nil]], \"963\" [:div [:p/code {:code \"(defn get-legacy-model-output [dataset]\\n  (-> dataset\\n      (legacy-model-definition)\\n      (prepare-data :ols)\\n      (ols-full-training)))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"946\" [:div [:p/code {:code \"(defn legacy-model-definition\\n  \\\"log(Used_ZTW) = a.Used_Duration + b.Used_Rating_Score + categorical variables\\\"\\n  [dataset]\\n  {:dataset         dataset\\n   :id-name         :Bond\\n   :y               {:column :Used_ZTW :predict-fn dfn/exp}\\n   :transformations [{:column :Used_ZTW :assoc-fn #(dfn/log (% :Used_ZTW))}]\\n   :one-hot         {:columns [:Country :Sector] :removals [:Country-BH :Sector-Fvanapvny]}\\n   :std-scale       {:columns [:Used_Duration :Used_Rating_Score] :scaler nil}})\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"1004\" [:div [:p/code {:code \"(def res (assoc qm :legacy (:predictions legacymodel) :new (:predictions newmodel) :svr (:predictions svrmodel)))\", :bg-class \"bg-light\"}] [:div nil]], \"974\" [:div [:p/code {:code \"(svr-predict-scalar svrmodel {:Used_Duration 1.16 :Used_Rating_Score 6.0 :Country \\\"BH\\\" :Sector \\\"Ovy_naq_Gnf\\\"})\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"962\" [:div [:p/code {:code \"(defn get-svr-model-output [dataset]\\n  (-> dataset\\n      (svr-model-definition)\\n      (prepare-data :svr)\\n      (svr-full-training 0.05 1000)))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"1007\" [:div [:p/code {:code \"(ols-predict-scalar newmodel {:Used_Duration 1.16 :Used_Rating_Score 6.0 :Country \\\"BH\\\" :Sector \\\"Ovy_naq_Gnf\\\"})\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"103.1329755725272\\n\"}]]], \"1006\" [:div [:p/code {:code \"(ols-predict-scalar legacymodel {:Used_Duration 1.16 :Used_Rating_Score 6.0 :Country \\\"BH\\\" :Sector \\\"Ovy_naq_Gnf\\\"})\", :bg-class \"bg-light\"}] [:div [:p/code {:code \"118.01535809799988\\n\"}]]], \"951\" [:div [:p/code {:code \"(defn build-many-columns [dataset features]\\n  (reduce build-column dataset features))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"961\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"981\" [:div [:p/code {:code \"(defn new-model-definition\\n  \\\"log(Used_ZTW) = a.log(Used_Duration) + b.Used_Rating_Score + categorical variables\\\"\\n  [dataset]\\n  {:dataset         dataset\\n   :id-name         :Bond\\n   :y               {:column :Used_ZTW :predict-fn dfn/exp}\\n   :transformations [{:column :Used_ZTW          :assoc-fn #(dfn/log (% :Used_ZTW))}\\n                     {:column :Used_Duration     :assoc-fn #(dfn/log (% :Used_Duration))}]\\n   :one-hot         {:columns [:Country :Sector] :removals [:Country-BH :Sector-Fvanapvny]}\\n   :std-scale       {:columns [:Used_Duration :Used_Rating_Score] :scaler nil}})\", :bg-class \"bg-light\"}] [:div nil]], \"952\" [:div [:p/code {:code \"(defn one-hot-reducer\\n  \\\"Removals only important for OLS models with small amount of features to avoid colinearity\\\"\\n  [source-dataset cols removals]\\n  (ds/remove-columns\\n    (reduce (fn [dataset col] (categorical/transform-one-hot dataset (categorical/fit-one-hot dataset col))) source-dataset cols)\\n    removals))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"980\" [:div [:p/code {:code \"(defn legacy-model-definition\\n  \\\"log(Used_ZTW) = a.Used_Duration + b.Used_Rating_Score + categorical variables\\\"\\n  [dataset]\\n  {:dataset         dataset\\n   :id-name         :Bond\\n   :y               {:column :Used_ZTW :predict-fn dfn/exp}\\n   :transformations [{:column :Used_ZTW :assoc-fn #(dfn/log (% :Used_ZTW))}]\\n   :one-hot         {:columns [:Country :Sector] :removals [:Country-BH :Sector-Fvanapvny]}\\n   :std-scale       {:columns [:Used_Duration :Used_Rating_Score] :scaler nil}})\", :bg-class \"bg-light\"}] [:div nil]], \"959\" [:div [:p/code {:code \"(defn ols-predict-scalar [data xmap]\\n  \\\"The order of the data needs to match the order of the training data AND we need the intercept first, set at 1.0\\n  Ugly hack here - normalizer is set to use log for new model\\n  \\\"\\n  (letfn [(normalizer [id log?] (let [{m :mean s :standard-deviation} (get-in data [:std-scale :scaler id])] (/ (- (if log? (Math/log (xmap id)) (xmap id)) m) s)))]\\n    ((get-in data [:y :predict-fn])\\n     (.predict\\n       ^LinearModel (:ols data)\\n       (double-array\\n         (into [1.0] (for [c (:features-cols data)]          ;into [1.0] is the intercept. It's not obvious!!!\\n                       (condp = c\\n                         :Used_Duration (normalizer :Used_Duration (some #{:Used_Duration} (map :column (:transformations data))))\\n                         :Used_Rating_Score (normalizer :Used_Rating_Score false)\\n                         (keyword (str \\\"Country-\\\" (xmap :Country))) 1.0\\n                         (keyword (str \\\"Sector-\\\" (xmap :Sector))) 1.0\\n                         0.0))))))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"956\" [:div [:p/code {:code \"(defn fit-RBF-SVR [x y sigma eps C]\\n  \\\"This is the SVR fit function, returning a smile.base.svm.KernelMachine which we can use to predict.\\n  x id a double double array, y is a double array, the rest are scalars.\\n  tol = 0.01 is irrelevant for the RBF (= Gaussian) kernel.\\n  sigma tunes the Kernel. The Python sklearn default is gamma = 'scale' where gamma = 1 / (2 * sigma^2)\\n  'scale' means gamma = 1 / (n_features * x.var()) hence sigma = sqrt(0.5 * n_features * x.var()) where x is flattened\\\"\\n  (.fit (SVR. (GaussianKernel. sigma) eps C 0.01) x y))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"944\" [:div nil [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"950\" [:div [:p/code {:code \"(defn build-column\\n  \\\"We can either assoc a new column or build from existing columns\\\"\\n  [dataset line]\\n  (if (contains? line :assoc-fn)\\n    (assoc dataset (:column line) ((:assoc-fn line) dataset))\\n    (ds/column-map dataset (:column line) (:map-fn line) nil (:arg-cols line))))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"964\" [:div [:p/code {:code \"(defn get-new-model-output [dataset]\\n  (-> dataset\\n      (new-model-definition)\\n      (prepare-data :ols)\\n      (ols-full-training)))\", :bg-class \"bg-light\"}] [:div [:p {:style {:font-style \"italic\", :font-family \"\\\"Lucida Console\\\", Courier, monospace\"}} [:small \"(not evaluated yet)\"]]]], \"991\" [:div [:p/code {:code \"(defn svr-full-training [data eps C]\\n  \\\"Putting it all together, the model / the predictions and the R2\\\"\\n  ;todo find out why I'm still getting a Reflection warning: call to method predict on smile.base.svm.KernelMachine can't be resolved (no such method)\\n  (let [kernel-machine (fit-RBF-SVR (:features-array data) (:y-array data) (:sigma data) eps C)\\n        raw-predictions (.predict ^KernelMachine kernel-machine (:features-array data))\\n        rss (RSS/of (:y-array data) raw-predictions)]\\n    (merge data {:kernel-machine kernel-machine :predictions ((get-in data [:y :predict-fn]) (vec raw-predictions)) :rsq (- 1 (/ rss (dfn/distance-squared (:y-array data) (repeat 0.))))})))\", :bg-class \"bg-light\"}] [:div nil]], \"997\" [:div [:p/code {:code \"(defn get-legacy-model-output [dataset]\\n  (-> dataset\\n      (legacy-model-definition)\\n      (prepare-data :ols)\\n      (ols-full-training)))\", :bg-class \"bg-light\"}] [:div nil]]}}");
     document.getElementById("loading").remove();
    </script>
</html>
